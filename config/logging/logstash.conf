input {
  beats {
    port => 5044
  }
}

filter {
  # Parse Flask application logs
  if [service] == "flask-app" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} - %{DATA:logger} - %{LOGLEVEL:level} - %{GREEDYDATA:log_message}" }
      # Add fallback for unmatched logs
      tag_on_failure => ["_grokparsefailure"]
    }
    
    # Only process if grok succeeded
    if "_grokparsefailure" not in [tags] {
      date {
        match => [ "timestamp", "ISO8601" ]
      }
      
      # Add severity based on log level
      if [level] == "ERROR" or [level] == "CRITICAL" {
        mutate {
          add_field => { "severity" => "high" }
        }
      } else if [level] == "WARNING" {
        mutate {
          add_field => { "severity" => "medium" }
        }
      } else {
        mutate {
          add_field => { "severity" => "low" }
        }
      }
    }
  }
  
  # Parse nginx logs
  if [service] == "nginx" {
    grok {
      match => { "message" => "%{IPORHOST:client_ip} - - \[%{HTTPDATE:timestamp}\] \"%{WORD:method} %{URIPATH:request_path}(?:%{URIPARAM:request_params})? HTTP/%{NUMBER:http_version}\" %{NUMBER:response_code} %{NUMBER:bytes_sent} \"%{DATA:referrer}\" \"%{DATA:user_agent}\"" }
      tag_on_failure => ["_nginx_grokparsefailure"]
    }
  }
  
  # Add common fields
  mutate {
    add_field => { "workshop" => "monitoring" }
    add_field => { "version" => "1.0" }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "workshop-logs-%{+YYYY.MM.dd}"
  }
  
  # For debugging - can be removed in production
  stdout {
    codec => rubydebug
  }
}

